/*
 * Copyright (C) 2006  Pekka Enberg
 *
 * This file is released under the GPL version 2. Please refer to the file
 * LICENSE for details.
 *
 * This file contains BURG specification for IA-32.
 */

#include <basic-block.h>
#include <expression.h>
#include <instruction.h>
#include <insn-selector.h>
#include <statement.h>
#include <string.h>
#include <stdio.h>

#define MBCGEN_TYPE struct basic_block
#define MBCOST_DATA struct basic_block
#define MBTREE_TYPE struct expression
#define MBTREE_OP(t) ((t)->type)
#define MBTREE_LEFT(t) ((t)->binary_left)
#define MBTREE_RIGHT(t) ((t)->binary_right)

%%

%term EXPR_LOCAL=2 EXPR_ADD=5

%start reg

reg:	EXPR_LOCAL	1
{
	bb_insert_insn(s, x86_op_membase_reg(MOV, REG_EBP, 12, REG_EAX));
}

reg:	EXPR_ADD(EXPR_LOCAL, reg) 1
{
	bb_insert_insn(s, x86_op_membase_reg(ADD, REG_EBP, 8, REG_EAX));
}

%%

static void emit_code(struct basic_block *bb, MBState *state, int goal)
{
	MBState *kids[2];
	int ern;
	const guint16 *nts;
	int i;

	ern = mono_burg_rule(state, goal);
	nts = mono_burg_nts[ern];
	mono_burg_kids(state, ern, kids);

	for (i = 0; nts[i]; i++) 
		emit_code(bb, kids[i], nts[i]);

	if (mono_burg_func[ern])
		mono_burg_func[ern](state, state->tree, bb);
	else
		printf("no code for rule %s\n", mono_burg_rule_string[ern]);
}

static void free_state(MBState *state)
{
	if (!state)
		return;

	free_state(state->left);
	free_state(state->right);

	g_free(state);
}

void insn_select(struct basic_block *bb)
{
	struct expression *expr = NULL;
	struct statement *stmt;
	MBState *state;

	stmt = list_entry(bb->stmt_list.next, struct statement, stmt_list_node);
	switch (stmt->type) {
		case STMT_RETURN:
			expr = stmt->return_value;
			break;
		default:
			break;
	};

	state = mono_burg_label(expr, bb);
	emit_code(bb, state, MB_NTERM_reg);

	free_state(state);
}

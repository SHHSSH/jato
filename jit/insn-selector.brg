/*
 * Copyright (C) 2006  Pekka Enberg
 *
 * This file is released under the GPL version 2. Please refer to the file
 * LICENSE for details.
 *
 * This file contains BURG specification for IA-32.
 */

#include <jit/basic-block.h>
#include <jit/expression.h>
#include <jit/insn-selector.h>
#include <jit/instruction.h>
#include <jit/jit-compiler.h>
#include <jit/statement.h>
#include <jit/x86-frame.h>

#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MBCGEN_TYPE struct basic_block
#define MBCOST_DATA struct basic_block
#define MBTREE_TYPE struct tree_node
#define MBTREE_OP(t) tree_op(t)
#define MBTREE_LEFT(t) tree->kids[0]
#define MBTREE_RIGHT(t) tree->kids[1]

#define MBMAX_OPCODES STMT_LAST

#define MONOBURG_LOG 1
#define HAVE_ARRAY_ELEM_INIT 1

static void method_args_cleanup(struct basic_block *bb, unsigned long args_count)
{
	unsigned long args_size = args_count * sizeof(unsigned long);
	bb_add_insn(bb, imm_reg_insn(OPC_ADD, args_size, REG_ESP));
}

%%

%termprefix EXPR_ OP_ STMT_

%start stmt

reg:	EXPR_VALUE	0
{
	struct expression *expr = to_expr(tree);

	bb_add_insn(s, imm_reg_insn(OPC_MOV, expr->value, REG_EAX));
}

reg:	EXPR_LOCAL	1
{
	struct expression *expr;
	unsigned long disp;
	
	expr = to_expr(tree);
	disp = frame_local_offset(s->b_parent->method, expr);

	bb_add_insn(s, membase_reg_insn(OPC_MOV, REG_EBP, disp, REG_EAX));
}

reg:	OP_ADD(EXPR_LOCAL, reg) 1
{
	struct expression *expr;
	unsigned long disp;

	expr = to_expr(tree);
	disp = frame_local_offset(s->b_parent->method, to_expr(expr->binary_left));

	bb_add_insn(s, membase_reg_insn(OPC_ADD, REG_EBP, disp, REG_EAX));
}

reg:	EXPR_INVOKE(arg) 1
{
	struct expression *expr;
	struct methodblock *method;
	void *target;

	expr   = to_expr(tree);
	method = expr->target_method;
	target = method->trampoline->objcode;

	bb_add_insn(s, rel_insn(OPC_CALL, (unsigned long) target));

	if (method->args_count)
		method_args_cleanup(s, method->args_count);
}

reg:	EXPR_INVOKEVIRTUAL(arg) 1
{
	struct expression *expr;
	unsigned long method_table_offset;
	unsigned long method_offset;
	unsigned long args_count;
	
	expr = to_expr(tree);
	method_table_offset = offsetof(struct classblock, method_table);
	method_offset = expr->method_index * sizeof(void *);

	/*
	 *	FIXME: This is horrible due to lack of per-method vtables.
	 */
	bb_add_insn(s, membase_reg_insn(OPC_MOV, REG_ESP, 0, REG_EAX));
	bb_add_insn(s, membase_reg_insn(OPC_MOV, REG_EAX, offsetof(struct object, class), REG_EAX));
	bb_add_insn(s, imm_reg_insn(OPC_ADD, sizeof(struct object), REG_EAX));
	bb_add_insn(s, membase_reg_insn(OPC_MOV, REG_EAX, method_table_offset, REG_EAX));
	bb_add_insn(s, membase_reg_insn(OPC_MOV, REG_EAX, method_offset, REG_EAX));
	bb_add_insn(s, membase_reg_insn(OPC_MOV, REG_EAX, offsetof(struct methodblock, trampoline), REG_EAX));
	bb_add_insn(s, membase_reg_insn(OPC_MOV, REG_EAX, offsetof(struct jit_trampoline, objcode), REG_EAX));
	bb_add_insn(s, reg_insn(OPC_CALL, REG_EAX));

	args_count = nr_args(to_expr(expr->args_list));
	if (args_count)
		method_args_cleanup(s, args_count);
}

reg:	OP_EQ(reg, EXPR_LOCAL) 1
{
	struct expression *expr;
	long offset;

	expr   = to_expr(tree);
	offset = frame_local_offset(s->b_parent->method, to_expr(expr->binary_right));

	bb_add_insn(s, membase_reg_insn(OPC_CMP, REG_EBP, offset, REG_EAX));
}

reg:	OP_EQ(reg, EXPR_VALUE) 1
{
	struct expression *expr, *rvalue;
	
	expr = to_expr(tree);
	rvalue = to_expr(expr->binary_right);

	bb_add_insn(s, imm_reg_insn(OPC_CMP, rvalue->value, REG_EAX));
}

reg:	EXPR_FIELD 1
{
	struct expression *expr;
	long offset;
	
	expr   = to_expr(tree);
	offset = offsetof(struct fieldblock, static_value);

	bb_add_insn(s, imm_reg_insn(OPC_MOV, (unsigned long) expr->field, REG_EAX));
	bb_add_insn(s, membase_reg_insn(OPC_MOV, REG_EAX, offset, REG_EAX));
}

arg:	EXPR_NO_ARGS
{
}

arg:	EXPR_ARG(EXPR_VALUE)
{
	struct expression *expr;
	unsigned long long imm;
	
	expr = to_expr(tree);
	imm  = to_expr(expr->arg_expression)->value;

	bb_add_insn(s, imm_insn(OPC_PUSH, imm));
}

arg:	EXPR_ARG(reg)
{
	bb_add_insn(s, reg_insn(OPC_PUSH, REG_EAX));
}

arg:	EXPR_ARGS_LIST(arg, arg)
{
}

stmt:	STMT_RETURN(reg)
{
	bb_add_insn(s, branch_insn(OPC_JMP, s->b_parent->exit_bb));
}

stmt:	STMT_VOID_RETURN
{
	bb_add_insn(s, branch_insn(OPC_JMP, s->b_parent->exit_bb));
}

stmt:	STMT_EXPRESSION(reg)
{
}

stmt:	STMT_STORE(EXPR_FIELD, EXPR_VALUE)
{
	struct statement *stmt;
	struct expression *store_dest;
	struct expression *store_src;
	unsigned long field_offset;
	unsigned long field_value;

	stmt = to_stmt(tree);
	store_dest = to_expr(stmt->store_dest);
	store_src  = to_expr(stmt->store_src);

	field_offset = offsetof(struct fieldblock, static_value);
	field_value  = store_src->value;

	bb_add_insn(s, imm_reg_insn(OPC_MOV, (unsigned long) store_dest->field, REG_EAX));
	bb_add_insn(s, imm_membase_insn(OPC_MOV, field_value, REG_EAX, field_offset));
}

stmt:	STMT_STORE(EXPR_LOCAL, reg)
{
	struct statement *stmt;
	struct expression *local;
	long offset;

	stmt   = to_stmt(tree);
	local  = to_expr(stmt->store_dest);
	offset = frame_local_offset(s->b_parent->method, local);

	bb_add_insn(s, reg_membase_insn(OPC_MOV, REG_EAX, REG_EBP, offset));
}

stmt:	STMT_IF(reg)
{
	struct statement *stmt = to_stmt(tree);

	bb_add_insn(s, branch_insn(OPC_JE, stmt->if_true));
}

%%

static void emit_code(struct basic_block *bb, MBState *state, int goal)
{
	MBState *kids[2];
	int ern;
	const guint16 *nts;
	int i;

	ern = mono_burg_rule(state, goal);
	nts = mono_burg_nts_data + mono_burg_nts[ern];
	mono_burg_kids(state, ern, kids);

	for (i = 0; nts[i]; i++) 
		emit_code(bb, kids[i], nts[i]);

	if (mono_burg_func[ern])
		mono_burg_func[ern](state, state->tree, bb);
	else
		printf("no code for rule %s\n", mono_burg_rule_string[ern]);
}

static void free_state(MBState *state)
{
	if (!state)
		return;

	free_state(state->left);
	free_state(state->right);

	g_free(state);
}

void insn_select(struct basic_block *bb)
{
	struct statement *stmt;
	MBState *state;

	mono_burg_init();

	list_for_each_entry(stmt, &bb->stmt_list, stmt_list_node) {
		state = mono_burg_label(&stmt->node, bb);
		emit_code(bb, state, MB_NTERM_stmt);
		free_state(state);
	}
}

/*
 * Copyright (C) 2006  Pekka Enberg
 *
 * This file is released under the GPL version 2. Please refer to the file
 * LICENSE for details.
 *
 * This file contains BURG specification for IA-32.
 */

#include <assert.h>
#include <basic-block.h>
#include <expression.h>
#include <instruction.h>
#include <insn-selector.h>
#include <statement.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>

static void expr_panic(enum expression_type type, const char *str_type)
{
	printf("%02x is %s\n", type, str_type);
	abort();
}

static bool is_leaf_expr(enum expression_type type)
{
	switch (type) {
	case EXPR_VALUE:
	case EXPR_FVALUE:
	case EXPR_LOCAL:
	case EXPR_TEMPORARY:
	case EXPR_ARRAY_DEREF:
	case EXPR_FIELD:
		return true;
	default:	
		break;
	}
	return false;
}

static struct tree_node *tree_left(struct tree_node *tree)
{
	struct expression *expr = to_expr(tree);
	enum expression_type type = expr_type(expr);

	if (is_leaf_expr(type))
		expr_panic(type, "leaf");

	return tree->kids[0];
}

static bool is_unary_expr(enum expression_type type)
{
	switch (type) {
	case EXPR_UNARY_OP:
	case EXPR_CONVERSION:
	case EXPR_INVOKE:
	case EXPR_ARG:
		return true;
	default:
		break;
	}
	return false;
}

static struct tree_node *tree_right(struct tree_node *tree)
{
	struct expression *expr = to_expr(tree);
	enum expression_type type = expr_type(expr);

	if (is_leaf_expr(type))
		expr_panic(type, "leaf");

	if (is_unary_expr(type))
		expr_panic(type, "unary");

	return tree->kids[1];
}

#define MBCGEN_TYPE struct basic_block
#define MBCOST_DATA struct basic_block
#define MBTREE_TYPE struct tree_node
#define MBTREE_OP(t) tree_op(t)
#define MBTREE_LEFT(t) tree_left(t)
#define MBTREE_RIGHT(t) tree_right(t)

#define MBMAX_OPCODES OP_LAST

%%

%termprefix EXPR_ OP_

%start reg

reg:	EXPR_VALUE	0
{
}

reg:	EXPR_LOCAL	1
{
	bb_insert_insn(s, x86_op_membase_reg(MOV, REG_EBP, 12, REG_EAX));
}

reg:	OP_ADD(EXPR_LOCAL, reg) 1
{
	bb_insert_insn(s, x86_op_membase_reg(ADD, REG_EBP, 8, REG_EAX));
}

reg:	EXPR_INVOKE 1
{
	struct insn *insn = alloc_insn(INSN_CALL);
	bb_insert_insn(s, insn);
}

reg: 	EXPR_ARG(reg)
{
	struct insn *insn = alloc_insn(INSN_PUSH);
	bb_insert_insn(s, insn);
}

reg:	EXPR_ARGS_LIST(reg, reg)
{
}

%%

static void emit_code(struct basic_block *bb, MBState *state, int goal)
{
	MBState *kids[2];
	int ern;
	const guint16 *nts;
	int i;

	ern = mono_burg_rule(state, goal);
	nts = mono_burg_nts[ern];
	mono_burg_kids(state, ern, kids);

	for (i = 0; nts[i]; i++) 
		emit_code(bb, kids[i], nts[i]);

	if (mono_burg_func[ern])
		mono_burg_func[ern](state, state->tree, bb);
	else
		printf("no code for rule %s\n", mono_burg_rule_string[ern]);
}

static void free_state(MBState *state)
{
	if (!state)
		return;

	free_state(state->left);
	free_state(state->right);

	g_free(state);
}

void insn_select(struct basic_block *bb)
{
	struct tree_node *tree = NULL;
	struct statement *stmt;
	MBState *state;

	mono_burg_init();

	stmt = list_entry(bb->stmt_list.next, struct statement, stmt_list_node);
	switch (stmt_type(stmt)) {
		case STMT_RETURN:
			tree = stmt->return_value;
			break;
		case STMT_EXPRESSION:
			tree = stmt->expression;
			break;
		default:
			assert(!"unknown statement type");
	};

	state = mono_burg_label(tree, bb);
	emit_code(bb, state, MB_NTERM_reg);

	free_state(state);
}

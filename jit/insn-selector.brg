/*
 * Copyright (C) 2006  Pekka Enberg
 *
 * This file is released under the GPL version 2. Please refer to the file
 * LICENSE for details.
 *
 * This file contains BURG specification for IA-32.
 */

#include <basic-block.h>
#include <insn-selector.h>
#include <jit/instruction.h>
#include <jit-compiler.h>
#include <jit/expression.h>
#include <jit/statement.h>
#include <jit/tree-printer.h>
#include <jit/x86-frame.h>
#include <vm/string.h>

#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MBCGEN_TYPE struct basic_block
#define MBCOST_DATA struct basic_block
#define MBTREE_TYPE struct tree_node
#define MBTREE_OP(t) tree_op(t)
#define MBTREE_LEFT(t) tree->kids[0]
#define MBTREE_RIGHT(t) tree->kids[1]

#define MBMAX_OPCODES STMT_LAST

#define MONOBURG_LOG 1
#define HAVE_ARRAY_ELEM_INIT 1

%%

%termprefix EXPR_ OP_ STMT_

%start stmt

reg:	EXPR_VALUE	0
{
}

reg:	EXPR_LOCAL	1
{
	struct expression *expr = to_expr(tree);
	unsigned long disp = frame_local_offset(expr);
	bb_insert_insn(s, membase_reg_insn(OPC_MOV, REG_EBP, disp, REG_EAX));
}

reg:	OP_ADD(EXPR_LOCAL, reg) 1
{
	struct expression *expr = to_expr(tree);
	unsigned long disp = frame_local_offset(to_expr(expr->binary_left));

	bb_insert_insn(s, membase_reg_insn(OPC_ADD, REG_EBP, disp, REG_EAX));
}

reg:	EXPR_INVOKE(arg) 1
{
	struct expression *expr = to_expr(tree);
	struct methodblock *method = expr->target_method;
	void *target = method->trampoline->objcode;

	bb_insert_insn(s, rel_insn(OPC_CALL, (unsigned long) target));

	if (method->args_count)
		bb_insert_insn(s, imm_reg_insn(OPC_ADD, method->args_count * sizeof(unsigned long), REG_ESP));
}

reg:	EXPR_INVOKEVIRTUAL(arg) 1
{
	unsigned long method_table_offset;
	unsigned long method_offset;
	struct expression *expr = to_expr(tree);

	bb_insert_insn(s, membase_reg_insn(OPC_MOV, REG_ESP, 0, REG_EAX));
	bb_insert_insn(s, membase_reg_insn(OPC_MOV, REG_EAX, offsetof(struct object, class), REG_EAX));

	method_table_offset = sizeof(struct object) + offsetof(struct classblock, method_table);
	bb_insert_insn(s, membase_reg_insn(OPC_MOV, REG_EAX, method_table_offset, REG_EAX));

	method_offset = expr->method_index * sizeof(void *);
	bb_insert_insn(s, membase_reg_insn(OPC_MOV, REG_EAX, method_offset, REG_EAX));

	bb_insert_insn(s, membase_reg_insn(OPC_MOV, REG_EAX, offsetof(struct methodblock, trampoline), REG_EAX));
	bb_insert_insn(s, membase_reg_insn(OPC_MOV, REG_EAX, offsetof(struct jit_trampoline, objcode), REG_EAX));
	bb_insert_insn(s, reg_insn(OPC_JMP, REG_EAX));
}

reg:	OP_EQ(reg, EXPR_LOCAL) 1
{
	struct expression *expr = to_expr(tree);
	unsigned long disp = frame_local_offset(to_expr(expr->binary_right));

	bb_insert_insn(s, membase_reg_insn(OPC_CMP, REG_EBP, disp, REG_EAX));
}

reg:	EXPR_FIELD 1
{
	unsigned long offset;
	struct expression *expr = to_expr(tree);

	offset = offsetof(struct fieldblock, static_value);

	bb_insert_insn(s, imm_reg_insn(OPC_MOV, (unsigned long) expr->field, REG_EAX));
	bb_insert_insn(s, membase_reg_insn(OPC_MOV, REG_EAX, offset, REG_EAX));
}

arg:	EXPR_NO_ARGS
{
}

arg:	EXPR_ARG(EXPR_VALUE)
{
	struct expression *expr = to_expr(tree);
	unsigned long long imm = to_expr(expr->arg_expression)->value;

	bb_insert_insn(s, imm_insn(OPC_PUSH, imm));
}

arg:	EXPR_ARG(reg)
{
	bb_insert_insn(s, reg_insn(OPC_PUSH, REG_EAX));
}

arg:	EXPR_ARGS_LIST(arg, arg)
{
}

stmt:	STMT_RETURN(reg)
{
}

stmt:	STMT_VOID_RETURN
{
}

stmt:	STMT_EXPRESSION(reg)
{
}

stmt:	STMT_STORE(EXPR_FIELD, EXPR_VALUE)
{
	struct statement *stmt;
	struct expression *store_dest;
	struct expression *store_src;
	unsigned long field_offset;
	unsigned long field_value;

	stmt = to_stmt(tree);
	store_dest = to_expr(stmt->store_dest);
	store_src  = to_expr(stmt->store_src);

	field_offset = offsetof(struct fieldblock, static_value);
	field_value  = store_src->value;

	bb_insert_insn(s, imm_reg_insn(OPC_MOV, (unsigned long) store_dest->field, REG_EAX));
	bb_insert_insn(s, imm_membase_insn(OPC_MOV, field_value, REG_EAX, field_offset));
}

stmt:	STMT_IF(reg)
{
	struct statement *stmt = to_stmt(tree);

	bb_insert_insn(s, branch_insn(OPC_JE, to_stmt(stmt->if_true)));
}

%%

static void emit_code(struct basic_block *bb, MBState *state, int goal)
{
	MBState *kids[2];
	int ern;
	const guint16 *nts;
	int i;

	ern = mono_burg_rule(state, goal);
	nts = mono_burg_nts_data + mono_burg_nts[ern];
	mono_burg_kids(state, ern, kids);

	for (i = 0; nts[i]; i++) 
		emit_code(bb, kids[i], nts[i]);

	if (mono_burg_func[ern])
		mono_burg_func[ern](state, state->tree, bb);
	else
		printf("no code for rule %s\n", mono_burg_rule_string[ern]);
}

static void free_state(MBState *state)
{
	if (!state)
		return;

	free_state(state->left);
	free_state(state->right);

	g_free(state);
}

#if 0
static void print_tree(struct tree_node *node)
{
	struct string *str = alloc_str();
	tree_print(node, str);
	printf(str->value);
	free_str(str);
}
#else
static inline void print_tree(struct tree_node *node)
{
}
#endif

void insn_select(struct basic_block *bb)
{
	struct statement *stmt;
	MBState *state;

	mono_burg_init();

	list_for_each_entry(stmt, &bb->stmt_list, stmt_list_node) {
		print_tree(&stmt->node);
		state = mono_burg_label(&stmt->node, bb);
		emit_code(bb, state, MB_NTERM_stmt);
		free_state(state);
	}
}

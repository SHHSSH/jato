/*
 * Instruction selector Monoburg specification for IA-32.
 *
 * Copyright (C) 2006  Pekka Enberg
 *
 * This file is released under the GPL version 2. Please refer to the file
 * LICENSE for details.
 */

#include <jit/basic-block.h>
#include <jit/expression.h>
#include <jit/insn-selector.h>
#include <jit/instruction.h>
#include <jit/jit-compiler.h>
#include <jit/statement.h>
#include <jit/x86-frame.h>

#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MBCGEN_TYPE struct basic_block
#define MBCOST_DATA struct basic_block
#define MBTREE_TYPE struct tree_node
#define MBTREE_OP(t) tree_op(t)
#define MBTREE_LEFT(t) tree->kids[0]
#define MBTREE_RIGHT(t) tree->kids[1]

#define MBMAX_OPCODES STMT_LAST

#define MONOBURG_LOG 1
#define HAVE_ARRAY_ELEM_INIT 1

static void method_args_cleanup(struct basic_block *bb, unsigned long args_count)
{
	unsigned long args_size = args_count * sizeof(u4);
	bb_add_insn(bb, imm_reg_insn(INSN_ADD_IMM_REG, args_size, REG_ESP));
}

static void binop_reg_local(struct basic_block *bb, struct tree_node *tree,
			    enum insn_type insn_type)
{
	struct expression *expr;
	unsigned long disp;

	expr = to_expr(tree);
	disp = frame_local_offset(bb->b_parent->method, to_expr(expr->binary_right));

	bb_add_insn(bb, membase_reg_insn(insn_type, REG_EBP, disp, REG_EAX));
}

static void binop_reg_value(struct basic_block *bb, struct tree_node *tree,
			    enum insn_type insn_type)
{
	struct expression *expr, *right;

	expr  = to_expr(tree);
	right = to_expr(expr->binary_right);

	bb_add_insn(bb, imm_reg_insn(insn_type, right->value, REG_EAX));
}

static void shift_reg_local(struct basic_block *bb, struct tree_node *tree,
			    enum insn_type insn_type)
{
	struct expression *expr;
	unsigned long disp;

	expr = to_expr(tree);
	disp = frame_local_offset(bb->b_parent->method, to_expr(expr->binary_right));

	bb_add_insn(bb, membase_reg_insn(INSN_MOV_MEMBASE_REG, REG_EBP, disp, REG_ECX));
	bb_add_insn(bb, reg_reg_insn(insn_type, REG_ECX, REG_EAX));
}

static enum insn_type br_binop_to_insn_type(enum binary_operator binop)
{
	enum insn_type ret;

	switch (binop) {
	case OP_EQ:
		ret = INSN_JE_BRANCH;
		break;
	case OP_NE:
		ret = INSN_JNE_BRANCH;
		break;
	default:
		assert(!"not a branch operator");
	};
	return ret;
}

%%

%termprefix EXPR_ OP_ STMT_

%start stmt

reg:	EXPR_VALUE	0
{
	struct expression *expr = to_expr(tree);

	bb_add_insn(s, imm_reg_insn(INSN_MOV_IMM_REG, expr->value, REG_EAX));
}

reg:	EXPR_LOCAL	1
{
	struct expression *expr;
	unsigned long disp;
	
	expr = to_expr(tree);
	disp = frame_local_offset(s->b_parent->method, expr);

	bb_add_insn(s, membase_reg_insn(INSN_MOV_MEMBASE_REG, REG_EBP, disp, REG_EAX));
}

reg:	OP_ADD(reg, EXPR_LOCAL) 1
{
	binop_reg_local(s, tree, INSN_ADD_MEMBASE_REG);
}

reg:	OP_ADD(reg, EXPR_VALUE) 1
{
	binop_reg_value(s, tree, INSN_ADD_IMM_REG);
}

reg:	OP_SUB(reg, EXPR_LOCAL) 1
{
	binop_reg_local(s, tree, INSN_SUB_MEMBASE_REG);
}

reg:	OP_MUL(reg, EXPR_LOCAL) 1
{
	binop_reg_local(s, tree, INSN_MUL_MEMBASE_REG);
}

reg:	OP_DIV(reg, EXPR_LOCAL) 1
{
	struct expression *expr;
	unsigned long disp;

	expr = to_expr(tree);
	disp = frame_local_offset(s->b_parent->method, to_expr(expr->binary_right));

	bb_add_insn(s, insn(INSN_CLTD));
	bb_add_insn(s, membase_reg_insn(INSN_DIV_MEMBASE_REG, REG_EBP, disp, REG_EAX));
}

reg:	OP_REM(reg, EXPR_LOCAL) 1
{
	struct expression *expr;
	unsigned long disp;

	expr = to_expr(tree);
	disp = frame_local_offset(s->b_parent->method, to_expr(expr->binary_right));

	bb_add_insn(s, insn(INSN_CLTD));
	bb_add_insn(s, membase_reg_insn(INSN_DIV_MEMBASE_REG, REG_EBP, disp, REG_EAX));
	bb_add_insn(s, reg_reg_insn(INSN_MOV_REG_REG, REG_EDX, REG_EAX));
}

reg:	OP_NEG(reg) 1
{
	bb_add_insn(s, reg_insn(INSN_NEG_REG, REG_EAX));
}

reg:	OP_SHL(reg, EXPR_LOCAL) 1
{
	shift_reg_local(s, tree, INSN_SHL_REG_REG);
}

reg:	OP_SHR(reg, EXPR_LOCAL) 1
{
	shift_reg_local(s, tree, INSN_SAR_REG_REG);
}

reg:	OP_USHR(reg, EXPR_LOCAL) 1
{
	shift_reg_local(s, tree, INSN_SHR_REG_REG);
}

reg:	OP_OR(reg, EXPR_LOCAL) 1
{
	binop_reg_local(s, tree, INSN_OR_MEMBASE_REG);
}

reg:	OP_AND(reg, EXPR_LOCAL) 1
{
	binop_reg_local(s, tree, INSN_AND_MEMBASE_REG);
}

reg:	OP_XOR(reg, EXPR_LOCAL) 1
{
	binop_reg_local(s, tree, INSN_XOR_MEMBASE_REG);
}

reg:	EXPR_INVOKE(arg) 1
{
	struct expression *expr;
	struct methodblock *method;
	void *target;

	expr   = to_expr(tree);
	method = expr->target_method;
	target = trampoline_ptr(method);

	bb_add_insn(s, rel_insn(INSN_CALL_REL, (unsigned long) target));

	if (method->args_count)
		method_args_cleanup(s, method->args_count);
}

reg:	EXPR_INVOKEVIRTUAL(arg) 1
{
	struct expression *expr;
	unsigned long method_table_offset;
	unsigned long method_offset;
	unsigned long args_count;
	
	expr = to_expr(tree);
	method_table_offset = offsetof(struct classblock, method_table);
	method_offset = expr->method_index * sizeof(void *);

	/*
	 *	FIXME: This is horrible due to lack of per-method vtables.
	 */
	bb_add_insn(s, membase_reg_insn(INSN_MOV_MEMBASE_REG, REG_ESP, 0, REG_EAX));
	bb_add_insn(s, membase_reg_insn(INSN_MOV_MEMBASE_REG, REG_EAX, offsetof(struct object, class), REG_EAX));
	bb_add_insn(s, imm_reg_insn(INSN_ADD_IMM_REG, sizeof(struct object), REG_EAX));
	bb_add_insn(s, membase_reg_insn(INSN_MOV_MEMBASE_REG, REG_EAX, method_table_offset, REG_EAX));
	bb_add_insn(s, membase_reg_insn(INSN_MOV_MEMBASE_REG, REG_EAX, method_offset, REG_EAX));
	bb_add_insn(s, membase_reg_insn(INSN_MOV_MEMBASE_REG, REG_EAX, offsetof(struct methodblock, trampoline), REG_EAX));
	bb_add_insn(s, membase_reg_insn(INSN_MOV_MEMBASE_REG, REG_EAX, offsetof(struct buffer, buf), REG_EAX));
	bb_add_insn(s, reg_insn(INSN_CALL_REG, REG_EAX));

	args_count = nr_args(to_expr(expr->args_list));
	if (args_count)
		method_args_cleanup(s, args_count);
}

reg:	OP_EQ(reg, EXPR_LOCAL) 1
{
	binop_reg_local(s, tree, INSN_CMP_MEMBASE_REG);
}

reg:	OP_EQ(reg, EXPR_VALUE) 1
{
	binop_reg_value(s, tree, INSN_CMP_IMM_REG);
}

reg:	OP_NE(reg, EXPR_LOCAL) 1
{
	binop_reg_local(s, tree, INSN_CMP_MEMBASE_REG);
}

reg:	OP_NE(reg, EXPR_VALUE) 1
{
	binop_reg_value(s, tree, INSN_CMP_IMM_REG);
}

reg:	EXPR_CLASS_FIELD 1
{
	struct expression *expr;
	long offset;
	
	expr   = to_expr(tree);
	offset = offsetof(struct fieldblock, static_value);

	bb_add_insn(s, imm_reg_insn(INSN_MOV_IMM_REG, (unsigned long) expr->class_field, REG_EAX));
	bb_add_insn(s, membase_reg_insn(INSN_MOV_MEMBASE_REG, REG_EAX, offset, REG_EAX));
}

reg:	EXPR_INSTANCE_FIELD(reg) 1
{
	struct expression *expr;

	expr = to_expr(tree);

	bb_add_insn(s, imm_reg_insn(INSN_ADD_IMM_REG, sizeof(struct object), REG_EAX));
	bb_add_insn(s, imm_reg_insn(INSN_MOV_IMM_REG, expr->instance_field->offset, REG_EDX));
	bb_add_insn(s, memindex_reg_insn(INSN_MOV_MEMINDEX_REG, REG_EAX, REG_EDX, 2, REG_EAX));
}

reg:	EXPR_NEW
{
	struct expression *expr;

	expr = to_expr(tree);

	bb_add_insn(s, imm_insn(INSN_PUSH_IMM, (unsigned long) expr->class));
	bb_add_insn(s, rel_insn(INSN_CALL_REL, (unsigned long) allocObject));
	method_args_cleanup(s, 1);
}

arg:	EXPR_NO_ARGS
{
}

arg:	EXPR_ARG(EXPR_VALUE)
{
	struct expression *expr;
	unsigned long long imm;
	
	expr = to_expr(tree);
	imm  = to_expr(expr->arg_expression)->value;

	bb_add_insn(s, imm_insn(INSN_PUSH_IMM, imm));
}

arg:	EXPR_ARG(reg)
{
	bb_add_insn(s, reg_insn(INSN_PUSH_REG, REG_EAX));
}

arg:	EXPR_ARGS_LIST(arg, arg)
{
}

stmt:	STMT_RETURN(reg)
{
	bb_add_insn(s, branch_insn(INSN_JMP_BRANCH, s->b_parent->exit_bb));
}

stmt:	STMT_VOID_RETURN
{
	bb_add_insn(s, branch_insn(INSN_JMP_BRANCH, s->b_parent->exit_bb));
}

stmt:	STMT_EXPRESSION(reg)
{
}

stmt:	STMT_STORE(EXPR_CLASS_FIELD, EXPR_VALUE)
{
	struct statement *stmt;
	struct expression *store_dest;
	struct expression *store_src;
	unsigned long field_offset;
	unsigned long field_value;

	stmt = to_stmt(tree);
	store_dest = to_expr(stmt->store_dest);
	store_src  = to_expr(stmt->store_src);

	field_offset = offsetof(struct fieldblock, static_value);
	field_value  = store_src->value;

	bb_add_insn(s, imm_reg_insn(INSN_MOV_IMM_REG, (unsigned long) store_dest->class_field, REG_EAX));
	bb_add_insn(s, imm_membase_insn(INSN_MOV_IMM_MEMBASE, field_value, REG_EAX, field_offset));
}

inst_field: EXPR_INSTANCE_FIELD(reg) 1
{
	struct expression *expr;

	expr = to_expr(tree);

	bb_add_insn(s, reg_reg_insn(INSN_MOV_REG_REG, REG_EAX, REG_ECX));
	bb_add_insn(s, imm_reg_insn(INSN_ADD_IMM_REG, sizeof(struct object), REG_ECX));
	bb_add_insn(s, imm_reg_insn(INSN_MOV_IMM_REG, expr->instance_field->offset, REG_EDX));
}

stmt:	STMT_STORE(inst_field, reg)
{
	struct expression *store_src;
	struct statement *stmt;

	stmt = to_stmt(tree);
	store_src = to_expr(stmt->store_src);

	bb_add_insn(s, reg_memindex_insn(INSN_MOV_REG_MEMINDEX, REG_EAX, REG_ECX, REG_EDX, 2));
}

stmt:	STMT_STORE(EXPR_LOCAL, reg)
{
	struct statement *stmt;
	struct expression *local;
	long offset;

	stmt   = to_stmt(tree);
	local  = to_expr(stmt->store_dest);
	offset = frame_local_offset(s->b_parent->method, local);

	bb_add_insn(s, reg_membase_insn(INSN_MOV_REG_MEMBASE, REG_EAX, REG_EBP, offset));
}

stmt:	STMT_IF(reg)
{
	struct expression *if_conditional;
	enum insn_type insn_type;
	struct statement *stmt;

	stmt = to_stmt(tree);
	if_conditional = to_expr(stmt->if_conditional);
	insn_type = br_binop_to_insn_type(expr_bin_op(if_conditional));

	bb_add_insn(s, branch_insn(insn_type, stmt->if_true));
}

%%

static void emit_code(struct basic_block *bb, MBState *state, int goal)
{
	MBState *kids[2];
	int ern;
	const guint16 *nts;
	int i;

	ern = mono_burg_rule(state, goal);
	nts = mono_burg_nts_data + mono_burg_nts[ern];
	mono_burg_kids(state, ern, kids);

	for (i = 0; nts[i]; i++) 
		emit_code(bb, kids[i], nts[i]);

	mono_burg_emit(ern, state, state->tree, bb);
}

static void free_state(MBState *state)
{
	if (!state)
		return;

	free_state(state->left);
	free_state(state->right);

	g_free(state);
}

void insn_select(struct basic_block *bb)
{
	struct statement *stmt;
	MBState *state;

	mono_burg_init();

	for_each_stmt(stmt, &bb->stmt_list) {
		state = mono_burg_label(&stmt->node, bb);
		emit_code(bb, state, MB_NTERM_stmt);
		free_state(state);
	}
}

/*
 * Copyright (C) 2006  Pekka Enberg
 *
 * This file is released under the GPL version 2. Please refer to the file
 * LICENSE for details.
 *
 * This file contains BURG specification for IA-32.
 */

#include <assert.h>
#include <basic-block.h>
#include <jit/expression.h>
#include <instruction.h>
#include <insn-selector.h>
#include <jit-compiler.h>
#include <jit/statement.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>

#define MBCGEN_TYPE struct basic_block
#define MBCOST_DATA struct basic_block
#define MBTREE_TYPE struct tree_node
#define MBTREE_OP(t) tree_op(t)
#define MBTREE_LEFT(t) tree->kids[0]
#define MBTREE_RIGHT(t) tree->kids[1]

#define MBMAX_OPCODES STMT_LAST

%%

%termprefix EXPR_ OP_ STMT_

%start stmt

reg:	EXPR_VALUE	0
{
}

reg:	EXPR_LOCAL	1
{
	bb_insert_insn(s, disp_reg_insn(OPC_MOV, REG_EBP, 12, REG_EAX));
}

reg:	OP_ADD(EXPR_LOCAL, reg) 1
{
	bb_insert_insn(s, disp_reg_insn(OPC_ADD, REG_EBP, 8, REG_EAX));
}

reg:	EXPR_INVOKE(arg) 1
{
	struct expression *expr = to_expr(tree);
	void *target = jit_prepare_for_exec(expr->target_method);

	bb_insert_insn(s, rel_insn(OPC_CALL, (unsigned long) target));
}

arg:	EXPR_NO_ARGS
{
}

arg:	EXPR_ARG(EXPR_VALUE)
{
	struct expression *expr = to_expr(tree);
	unsigned long long imm = to_expr(expr->arg_expression)->value;

	bb_insert_insn(s, imm_insn(OPC_PUSH, imm));
}

arg:	EXPR_ARGS_LIST(arg, arg)
{
}

stmt:	STMT_RETURN(reg)
{
}

stmt:	STMT_VOID_RETURN
{
}

stmt:	STMT_EXPRESSION(reg)
{
}

%%

static void emit_code(struct basic_block *bb, MBState *state, int goal)
{
	MBState *kids[2];
	int ern;
	const guint16 *nts;
	int i;

	ern = mono_burg_rule(state, goal);
	nts = mono_burg_nts[ern];
	mono_burg_kids(state, ern, kids);

	for (i = 0; nts[i]; i++) 
		emit_code(bb, kids[i], nts[i]);

	if (mono_burg_func[ern])
		mono_burg_func[ern](state, state->tree, bb);
	else
		printf("no code for rule %s\n", mono_burg_rule_string[ern]);
}

static void free_state(MBState *state)
{
	if (!state)
		return;

	free_state(state->left);
	free_state(state->right);

	g_free(state);
}

void insn_select(struct basic_block *bb)
{
	struct statement *stmt;
	MBState *state;

	mono_burg_init();

	stmt = list_entry(bb->stmt_list.next, struct statement, stmt_list_node);
	
	state = mono_burg_label(&stmt->node, bb);
	emit_code(bb, state, MB_NTERM_stmt);

	free_state(state);
}

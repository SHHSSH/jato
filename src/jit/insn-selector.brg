/*
 * Copyright (C) 2006  Pekka Enberg
 *
 * This file is released under the GPL version 2. Please refer to the file
 * LICENSE for details.
 *
 * This file contains BURG specification for IA-32.
 */

#include <basic-block.h>
#include <expression.h>
#include <instruction.h>
#include <insn-selector.h>
#include <string.h>
#include <stdio.h>

#define MBCGEN_TYPE struct basic_block
#define MBCOST_DATA struct basic_block
#define MBTREE_TYPE struct expression
#define MBTREE_OP(t) ((t)->type)
#define MBTREE_LEFT(t) ((t)->binary_left)
#define MBTREE_RIGHT(t) ((t)->binary_right)

%%

%term EXPR_TEMPORARY=3 EXPR_ADD=5

%start reg

reg:	EXPR_TEMPORARY	0

reg:	EXPR_ADD(reg, reg) 1
{
	s->insn = alloc_insn(ADD, tree->binary_right->temporary,
			     tree->binary_left->temporary);
}

%%

static int non_terminal(struct expression *tree)
{
	return tree->binary_left || tree->binary_right;
}

static void emit_code(struct basic_block *bb, MBState *state, int goal)
{
	MBState *kids[2];
	int ern;
	const guint16 *nts;
	int i;

	ern = mono_burg_rule(state, goal);
	nts = mono_burg_nts[ern];
	mono_burg_kids(state, ern, kids);

	for (i = 0; nts[i]; i++) 
		emit_code(bb, kids[i], nts[i]);

	if (non_terminal(state->tree)) {
		if (mono_burg_func[ern])
			mono_burg_func[ern](state, state->tree, bb);
		else
			printf("no code for rule %s\n", mono_burg_rule_string[ern]);
	} else
		if (mono_burg_func[ern])
			printf("unused code in rule %s\n", mono_burg_rule_string[ern]);
}

static void free_state(MBState *state)
{
	if (!state)
		return;

	free_state(state->left);
	free_state(state->right);

	g_free(state);
}

void insn_select(struct basic_block *bb, struct expression *expr)
{
	MBState *state;

	state = mono_burg_label(expr, bb);
	emit_code(bb, state, MB_NTERM_reg);

	free_state(state);
}

/*
 * Instruction selector Monoburg specification for IA-32.
 *
 * Copyright (C) 2006  Pekka Enberg
 *
 * This file is released under the GPL version 2. Please refer to the file
 * LICENSE for details.
 */

#include <jit/basic-block.h>
#include <jit/compilation-unit.h>
#include <jit/compiler.h>
#include <jit/expression.h>
#include <jit/statement.h>

#include <arch/instruction.h>
#include <arch/stack-frame.h>

#include <assert.h>
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MBCGEN_TYPE struct basic_block
#define MBCOST_DATA struct basic_block
#define MBTREE_TYPE struct tree_node
#define MBTREE_OP(t) tree_op(t)
#define MBTREE_LEFT(t) tree->kids[0]
#define MBTREE_RIGHT(t) tree->kids[1]
#define MBREG_TYPE struct var_info *

#define MBMAX_OPCODES STMT_LAST

#define MONOBURG_LOG 1
#define HAVE_ARRAY_ELEM_INIT 1

static void method_args_cleanup(struct basic_block *bb, unsigned long args_count)
{
	struct var_info *stack_ptr;
	unsigned long args_size;

	stack_ptr = bb->b_parent->stack_ptr;
	args_size = args_count * sizeof(u4);

	bb_add_insn(bb, imm_reg_insn(INSN_ADD_IMM_REG, args_size, stack_ptr));
}

struct _MBState;

static void binop_reg_local(struct _MBState *, struct basic_block *, struct tree_node *, enum insn_type);
static void binop_reg_value(struct _MBState *, struct basic_block *, struct tree_node *, enum insn_type);
static void shift_reg_local(struct _MBState *, struct basic_block *, struct tree_node *, enum insn_type);

static enum insn_type br_binop_to_insn_type(enum binary_operator binop)
{
	enum insn_type ret;

	switch (binop) {
	case OP_EQ:
		ret = INSN_JE_BRANCH;
		break;
	case OP_NE:
		ret = INSN_JNE_BRANCH;
		break;
	default:
		assert(!"not a branch operator");
	};
	return ret;
}

%%

%termprefix EXPR_ OP_ STMT_

%start stmt

reg:	EXPR_VALUE	0
{
	struct expression *expr;
	struct var_info *result;

	expr = to_expr(tree);

	result = get_fixed_var(s->b_parent, REG_EAX);
	state->reg1 = result;

	bb_add_insn(s, imm_reg_insn(INSN_MOV_IMM_REG, expr->value, result));
}

reg:	EXPR_LOCAL	1
{
	struct compilation_unit *cu = s->b_parent;
	struct expression *expr;
	struct stack_slot *slot;
	struct var_info *result;
	
	expr = to_expr(tree);
	slot = get_local_slot(cu->stack_frame, expr->local_index);

	result = get_fixed_var(s->b_parent, REG_EAX);
	state->reg1 = result;

	bb_add_insn(s, memlocal_reg_insn(INSN_MOV_MEMLOCAL_REG, slot, result));
}

reg:   EXPR_VAR
{
	struct expression *expr;

	expr = to_expr(tree);

	state->reg1 = expr->var;
}

reg:	OP_ADD(reg, EXPR_LOCAL) 1
{
	binop_reg_local(state, s, tree, INSN_ADD_MEMBASE_REG);
}

reg:	OP_ADD(reg, EXPR_VALUE) 1
{
	binop_reg_value(state, s, tree, INSN_ADD_IMM_REG);
}

reg:	OP_SUB(reg, EXPR_LOCAL) 1
{
	binop_reg_local(state, s, tree, INSN_SUB_MEMBASE_REG);
}

reg:	OP_MUL(reg, EXPR_LOCAL) 1
{
	binop_reg_local(state, s, tree, INSN_MUL_MEMBASE_REG);
}

reg:	OP_DIV(reg, EXPR_LOCAL) 1
{
	struct var_info *edx, *result, *frame_ptr;
	struct expression *expr;
	unsigned long disp;

	expr = to_expr(tree);
	disp = frame_local_offset(s->b_parent->method, to_expr(expr->binary_right));

	edx = get_fixed_var(s->b_parent, REG_EDX);
	result = get_fixed_var(s->b_parent, REG_EAX);
	state->reg1 = result;

	frame_ptr = s->b_parent->frame_ptr;

	bb_add_insn(s, reg_reg_insn(INSN_CLTD_REG_REG, result, edx));
	bb_add_insn(s, membase_reg_insn(INSN_DIV_MEMBASE_REG, frame_ptr, disp, result));
}

reg:	OP_REM(reg, EXPR_LOCAL) 1
{
	struct var_info *edx, *result, *frame_ptr, *remainder;
	struct expression *expr;
	unsigned long disp;

	expr = to_expr(tree);
	disp = frame_local_offset(s->b_parent->method, to_expr(expr->binary_right));

	edx = get_fixed_var(s->b_parent, REG_EDX);
	result = get_fixed_var(s->b_parent, REG_EAX);
	state->reg1 = result;

	frame_ptr = s->b_parent->frame_ptr;
	remainder = get_fixed_var(s->b_parent, REG_EDX);

	bb_add_insn(s, reg_reg_insn(INSN_CLTD_REG_REG, result, edx));
	bb_add_insn(s, membase_reg_insn(INSN_DIV_MEMBASE_REG, frame_ptr, disp, result));
	bb_add_insn(s, reg_reg_insn(INSN_MOV_REG_REG, remainder, result));
}

reg:	OP_NEG(reg) 1
{
	struct var_info *result;

	result = get_fixed_var(s->b_parent, REG_EAX);
	state->reg1 = result;

	bb_add_insn(s, reg_insn(INSN_NEG_REG, result));
}

reg:	OP_SHL(reg, EXPR_LOCAL) 1
{
	shift_reg_local(state, s, tree, INSN_SHL_REG_REG);
}

reg:	OP_SHR(reg, EXPR_LOCAL) 1
{
	shift_reg_local(state, s, tree, INSN_SAR_REG_REG);
}

reg:	OP_USHR(reg, EXPR_LOCAL) 1
{
	shift_reg_local(state, s, tree, INSN_SHR_REG_REG);
}

reg:	OP_OR(reg, EXPR_LOCAL) 1
{
	binop_reg_local(state, s, tree, INSN_OR_MEMBASE_REG);
}

reg:	OP_AND(reg, EXPR_LOCAL) 1
{
	binop_reg_local(state, s, tree, INSN_AND_MEMBASE_REG);
}

reg:	OP_XOR(reg, EXPR_LOCAL) 1
{
	binop_reg_local(state, s, tree, INSN_XOR_MEMBASE_REG);
}

reg:	EXPR_INVOKE(arg) 1
{
	struct methodblock *method;
	struct expression *expr;
	struct var_info *var;
	void *target;

	expr   = to_expr(tree);
	method = expr->target_method;
	target = trampoline_ptr(method);

	var = get_fixed_var(s->b_parent, REG_EAX);
	state->reg1 = var;

	bb_add_insn(s, rel_insn(INSN_CALL_REL, (unsigned long) target));

	if (method->args_count)
		method_args_cleanup(s, method->args_count);
}

reg:	EXPR_INVOKEVIRTUAL(arg) 1
{
	unsigned long method_table_offset;
	struct var_info *return_value;
	struct var_info *call_target;
	unsigned long method_offset;
	struct var_info *stack_ptr;
	unsigned long args_count;
	struct expression *expr;
	
	expr = to_expr(tree);
	method_table_offset = offsetof(struct classblock, method_table);
	method_offset = expr_method_index(expr) * sizeof(void *);

	return_value = get_fixed_var(s->b_parent, REG_EAX);
	state->reg1 = return_value;

	call_target = get_fixed_var(s->b_parent, REG_EAX);
	stack_ptr = get_fixed_var(s->b_parent, REG_ESP);

	/*
	 *	FIXME: This is horrible due to lack of per-method vtables.
	 */
	bb_add_insn(s, membase_reg_insn(INSN_MOV_MEMBASE_REG, stack_ptr, 0, call_target));
	bb_add_insn(s, membase_reg_insn(INSN_MOV_MEMBASE_REG, call_target, offsetof(struct object, class), call_target));
	bb_add_insn(s, imm_reg_insn(INSN_ADD_IMM_REG, sizeof(struct object), call_target));
	bb_add_insn(s, membase_reg_insn(INSN_MOV_MEMBASE_REG, call_target, method_table_offset, call_target));
	bb_add_insn(s, membase_reg_insn(INSN_MOV_MEMBASE_REG, call_target, method_offset, call_target));
	bb_add_insn(s, membase_reg_insn(INSN_MOV_MEMBASE_REG, call_target, offsetof(struct methodblock, trampoline), call_target));
	bb_add_insn(s, membase_reg_insn(INSN_MOV_MEMBASE_REG, call_target, offsetof(struct buffer, buf), call_target));
	bb_add_insn(s, reg_insn(INSN_CALL_REG, call_target));

	args_count = nr_args(to_expr(expr->args_list));
	if (args_count)
		method_args_cleanup(s, args_count);
}

reg:	OP_EQ(reg, EXPR_LOCAL) 1
{
	binop_reg_local(state, s, tree, INSN_CMP_MEMBASE_REG);
}

reg:	OP_EQ(reg, EXPR_VALUE) 1
{
	binop_reg_value(state, s, tree, INSN_CMP_IMM_REG);
}

reg:	OP_NE(reg, EXPR_LOCAL) 1
{
	binop_reg_local(state, s, tree, INSN_CMP_MEMBASE_REG);
}

reg:	OP_NE(reg, EXPR_VALUE) 1
{
	binop_reg_value(state, s, tree, INSN_CMP_IMM_REG);
}

reg:	EXPR_CLASS_FIELD 1
{
	struct var_info *result;
	struct expression *expr;
	long offset;
	
	expr   = to_expr(tree);
	offset = offsetof(struct fieldblock, static_value);

	result = get_fixed_var(s->b_parent, REG_EAX);
	state->reg1 = result;

	bb_add_insn(s, imm_reg_insn(INSN_MOV_IMM_REG, (unsigned long) expr->class_field, result));
	bb_add_insn(s, membase_reg_insn(INSN_MOV_MEMBASE_REG, result, offset, result));
}

reg:	EXPR_INSTANCE_FIELD(reg) 1
{
	struct var_info *base, *index, *result;
	struct expression *expr;

	expr = to_expr(tree);

	base = state->left->reg1;
	index = get_fixed_var(s->b_parent, REG_EDX);
	result = get_fixed_var(s->b_parent, REG_EAX);
	state->reg1 = result;

	bb_add_insn(s, imm_reg_insn(INSN_ADD_IMM_REG, sizeof(struct object), base));
	bb_add_insn(s, imm_reg_insn(INSN_MOV_IMM_REG, expr->instance_field->offset, index));
	bb_add_insn(s, memindex_reg_insn(INSN_MOV_MEMINDEX_REG, base, index, 2, result));
}

reg:	EXPR_NEW
{
	struct expression *expr;
	struct var_info *var;

	expr = to_expr(tree);

	var = get_fixed_var(s->b_parent, REG_EAX);
	state->reg1 = var;

	bb_add_insn(s, imm_insn(INSN_PUSH_IMM, (unsigned long) expr->class));
	bb_add_insn(s, rel_insn(INSN_CALL_REL, (unsigned long) allocObject));
	method_args_cleanup(s, 1);
}

reg:	EXPR_NEWARRAY(reg)
{
	struct var_info *var, *size;
	struct expression *expr;

	expr = to_expr(tree);

	var = get_var(s->b_parent);
	state->reg1 = var;

	size = state->left->reg1;

	bb_add_insn(s, reg_insn(INSN_PUSH_REG, size));
	bb_add_insn(s, imm_insn(INSN_PUSH_IMM, expr->array_type));
	bb_add_insn(s, rel_insn(INSN_CALL_REL, (unsigned long) allocTypeArray));

	method_args_cleanup(s, 2);
}

reg:    EXPR_ANEWARRAY(reg)
{
        struct var_info *var, *size;
        struct expression *expr;

        expr = to_expr(tree);

        var = get_var(s->b_parent);
        state->reg1 = var;

        size = state->left->reg1;

        bb_add_insn(s, imm_insn(INSN_PUSH_IMM, sizeof(struct object *)));
        bb_add_insn(s, reg_insn(INSN_PUSH_REG, size));
        bb_add_insn(s, imm_insn(INSN_PUSH_IMM, (unsigned long) expr->anewarray_ref_type));
        bb_add_insn(s, rel_insn(INSN_CALL_REL, (unsigned long) allocArray));

        method_args_cleanup(s, 3);
}

arg:	EXPR_NO_ARGS
{
}

arg:	EXPR_ARG(EXPR_VALUE)
{
	struct expression *expr;
	unsigned long long imm;
	
	expr = to_expr(tree);
	imm  = to_expr(expr->arg_expression)->value;

	bb_add_insn(s, imm_insn(INSN_PUSH_IMM, imm));
}

arg:	EXPR_ARG(reg)
{
	struct var_info *src;

	src = state->left->reg1;

	bb_add_insn(s, reg_insn(INSN_PUSH_REG, src));
}

arg:	EXPR_ARGS_LIST(arg, arg)
{
}

stmt:	STMT_RETURN(reg)
{
	bb_add_insn(s, branch_insn(INSN_JMP_BRANCH, s->b_parent->exit_bb));
}

stmt:	STMT_VOID_RETURN
{
	bb_add_insn(s, branch_insn(INSN_JMP_BRANCH, s->b_parent->exit_bb));
}

stmt:	STMT_EXPRESSION(reg)
{
}

stmt:	STMT_STORE(EXPR_CLASS_FIELD, EXPR_VALUE)
{
	struct expression *store_dest;
	struct expression *store_src;
	unsigned long field_offset;
	unsigned long field_value;
	struct var_info *offset;
	struct statement *stmt;

	stmt = to_stmt(tree);
	store_dest = to_expr(stmt->store_dest);
	store_src  = to_expr(stmt->store_src);

	field_offset = offsetof(struct fieldblock, static_value);
	field_value  = store_src->value;

	offset = get_fixed_var(s->b_parent, REG_EAX);

	bb_add_insn(s, imm_reg_insn(INSN_MOV_IMM_REG, (unsigned long) store_dest->class_field, offset));
	bb_add_insn(s, imm_membase_insn(INSN_MOV_IMM_MEMBASE, field_value, offset, field_offset));
}

inst_field: EXPR_INSTANCE_FIELD(reg) 1
{
	struct var_info *src, *base, *index;
	struct expression *expr;

	expr = to_expr(tree);

	src = state->left->reg1;

	base = get_fixed_var(s->b_parent, REG_ECX);
	state->reg1 = base;

	index = get_fixed_var(s->b_parent, REG_EDX);
	state->reg2 = index;

	bb_add_insn(s, reg_reg_insn(INSN_MOV_REG_REG, src, base));
	bb_add_insn(s, imm_reg_insn(INSN_ADD_IMM_REG, sizeof(struct object), base));
	bb_add_insn(s, imm_reg_insn(INSN_MOV_IMM_REG, expr->instance_field->offset, index));
}

stmt:	STMT_STORE(inst_field, reg)
{
	struct var_info *src, *base, *index;
	struct expression *store_src;
	struct statement *stmt;

	stmt = to_stmt(tree);
	store_src = to_expr(stmt->store_src);
	src = state->right->reg1;

	base = state->left->reg1;
	index = state->left->reg2;

	bb_add_insn(s, reg_memindex_insn(INSN_MOV_REG_MEMINDEX, src, base, index, 2));
}

stmt:	STMT_STORE(EXPR_LOCAL, reg)
{
	struct compilation_unit *cu = s->b_parent;
	struct expression *local;
	struct stack_slot *slot;
	struct statement *stmt;
	struct var_info *src;

	src = state->right->reg1;

	stmt = to_stmt(tree);
	local = to_expr(stmt->store_dest);
	slot = get_local_slot(cu->stack_frame, local->local_index);

	bb_add_insn(s, reg_memlocal_insn(INSN_MOV_REG_MEMLOCAL, src, slot));
}

stmt:  STMT_STORE(EXPR_VAR, reg)
{
	struct var_info *src, *dest;
	struct statement *stmt;

	stmt = to_stmt(tree);
	dest = to_expr(stmt->store_dest)->var;
	src = state->right->reg1;

	bb_add_insn(s, reg_reg_insn(INSN_MOV_REG_REG, src, dest));
}

stmt:	STMT_IF(reg)
{
	struct expression *if_conditional;
	enum insn_type insn_type;
	struct statement *stmt;

	stmt = to_stmt(tree);
	if_conditional = to_expr(stmt->if_conditional);
	insn_type = br_binop_to_insn_type(expr_bin_op(if_conditional));

	bb_add_insn(s, branch_insn(insn_type, stmt->if_true));
}

%%

static void binop_reg_local(struct _MBState *state, struct basic_block *bb,
			    struct tree_node *tree, enum insn_type insn_type)
{
	struct var_info *result, *frame_ptr;
	struct expression *expr;
	unsigned long disp;

	result = get_fixed_var(bb->b_parent, REG_EAX);
	state->reg1 = result;

	expr = to_expr(tree);
	disp = frame_local_offset(bb->b_parent->method, to_expr(expr->binary_right));

	frame_ptr = bb->b_parent->frame_ptr;

	bb_add_insn(bb, membase_reg_insn(insn_type, frame_ptr, disp, result));
}

static void binop_reg_value(struct _MBState *state, struct basic_block *bb,
			    struct tree_node *tree, enum insn_type insn_type)
{
	struct expression *expr, *right;
	struct var_info *result;

	result = get_fixed_var(bb->b_parent, REG_EAX);
	state->reg1 = result;

	expr  = to_expr(tree);
	right = to_expr(expr->binary_right);

	bb_add_insn(bb, imm_reg_insn(insn_type, right->value, result));
}

static void shift_reg_local(struct _MBState *state, struct basic_block *bb,
			    struct tree_node *tree, enum insn_type insn_type)
{
	struct var_info *result, *frame_ptr, *shift_count;
	struct expression *expr;
	unsigned long disp;

	result = get_fixed_var(bb->b_parent, REG_EAX);
	state->reg1 = result;

	expr = to_expr(tree);
	disp = frame_local_offset(bb->b_parent->method, to_expr(expr->binary_right));

	frame_ptr = bb->b_parent->frame_ptr;
	shift_count = get_fixed_var(bb->b_parent, REG_ECX);

	bb_add_insn(bb, membase_reg_insn(INSN_MOV_MEMBASE_REG, frame_ptr, disp, shift_count));
	bb_add_insn(bb, reg_reg_insn(insn_type, shift_count, result));
}

static void emit_code(struct basic_block *bb, MBState *state, int goal)
{
	MBState *kids[2];
	int ern;
	const guint16 *nts;
	int i;

	ern = mono_burg_rule(state, goal);
	nts = mono_burg_nts_data + mono_burg_nts[ern];
	mono_burg_kids(state, ern, kids);

	for (i = 0; nts[i]; i++) 
		emit_code(bb, kids[i], nts[i]);

	mono_burg_emit(ern, state, state->tree, bb);
}

static void free_state(MBState *state)
{
	if (!state)
		return;

	free_state(state->left);
	free_state(state->right);

	g_free(state);
}

static void insn_select(struct basic_block *bb)
{
	struct statement *stmt;
	MBState *state;

	mono_burg_init();

	for_each_stmt(stmt, &bb->stmt_list) {
		state = mono_burg_label(&stmt->node, bb);
		emit_code(bb, state, MB_NTERM_stmt);
		free_state(state);
	}
}

int select_instructions(struct compilation_unit *cu)
{
	struct basic_block *bb;
	int err = 0;

	cu->frame_ptr = get_fixed_var(cu, REG_EBP);
	if (!cu->frame_ptr) {
		err = -ENOMEM;
		goto out;
	}

	cu->stack_ptr = get_fixed_var(cu, REG_ESP);
	if (!cu->stack_ptr) {
		err = -ENOMEM;
		goto out;
	}

	for_each_basic_block(bb, &cu->bb_list)
		insn_select(bb);

  out:
	return err;
}

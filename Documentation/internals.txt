Jato Virtual Machine Internals
==============================
Pekka Enberg
2011

Introduction
------------

This manual documents the internals of the Jato virtual machine.

The reader is expected to have some basic knowledge of the C programming
language, Java Virtual Machine (JVM) architecture, and machine architecture.

- Java Virtual Machine specification

- Intel Manuals

- The Java Virtual Machine

Structure of the Virtual Machine
--------------------------------

Classes
~~~~~~~

Methods
~~~~~~~

Fields
~~~~~~

Objects
~~~~~~~

Exceptions
~~~~~~~~~~

Java Runtime Interface 
----------------------

Structure of the Just-in-Time Compiler
--------------------------------------

Subroutine inlining
~~~~~~~~~~~~~~~~~~~

Control-Flow Graph Analysis
~~~~~~~~~~~~~~~~~~~~~~~~~~~

BC2IR
~~~~~

Instruction Selection
~~~~~~~~~~~~~~~~~~~~~

The instruction selector takes the HIR as an input and outputs LIR. The actual
instruction selector is generated from a Monoburg rules file (e.g.
arch/x86/insn-selector_32.brg).

Static-Single Assignment (SSA) Form
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Liveness analysis
~~~~~~~~~~~~~~~~~

- Use-def

Register allocation
~~~~~~~~~~~~~~~~~~~

Resolution Blocks
^^^^^^^^^^^^^^^^^

The resolution blocks were introduced to solve the problem with reloading
registers when jumping from one (source) basic block to another basic block
(destination).

Typically when you have a virtual register which has live ranges before source
block and in the destination block, what you must do is put MOV instructions at
the end of the source basic block which restore register value from a spill
slot. Actually you must put them before the JMP instruction if there is one at
the end of source block.

Now, it might be the case that the ending JMP instruction is using a virtual
register, which is allocated the same machine register as is to one of the
virtual registers which are reloaded. If movs are before the jump, then the
register which is used by JMP would by clobbered by those reload instructions
and we would not jump into the right place. This happens because register
allocator sees all those virtual registers as not live in the source block. As
one might think of many different solutions to this problem, introducing
resolution blocks was one that was probably the simplest one to implement. We
put reload MOVs into an intermediate block on each (?) edge to avoid the
problem of clobbering registers allocated to not-yet-dead virtual registers.

Code Generation
~~~~~~~~~~~~~~~

Intermediate Representations
----------------------------


High-Level Intermediate Representation (HIR)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

For the front-end, we use a high-level intermediate representation (HIR) that
is a forest of expression trees. That is, a compilation unit (a method) is
divided into basic blocks that contain a list of statements and each statement
can operate on an expression tree. Examples of statements include STMT_STORE
that stores an expression to a local variable and STMT_IF that does conditional
branch. The simplest form of expression is EXPR_VALUE which represents a
constant value but there are more complex types of expressions including binary
operations (EXPR_BINOP) and method invocation (EXPR_INVOKE).

- struct statement

- struct expression

Low-Level Intermediate Representation (LIR)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

- struct operand

- struct insn

Machine Architecture Support
----------------------------

Application Binary Interface (ABI)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Instruction Encoding
~~~~~~~~~~~~~~~~~~~~
